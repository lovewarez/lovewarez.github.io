<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>User Interface - RuggRogue Source Code Guide</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Design and source code breakdown of a simple roguelike">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="book/outlink.css">

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Introduction</a></li><li class="chapter-item expanded "><a href="dependencies.html"><strong aria-hidden="true">1.</strong> Dependencies</a></li><li class="chapter-item expanded "><a href="source-code-layout.html"><strong aria-hidden="true">2.</strong> Source Code Layout</a></li><li class="chapter-item expanded "><a href="overall-game-flow.html"><strong aria-hidden="true">3.</strong> Overall Game Flow</a></li><li class="chapter-item expanded "><a href="event-handling.html"><strong aria-hidden="true">4.</strong> Event Handling</a></li><li class="chapter-item expanded "><a href="rendering.html"><strong aria-hidden="true">5.</strong> Rendering</a></li><li class="chapter-item expanded "><a href="user-interface.html" class="active"><strong aria-hidden="true">6.</strong> User Interface</a></li><li class="chapter-item expanded "><a href="options.html"><strong aria-hidden="true">7.</strong> Options</a></li><li class="chapter-item expanded "><a href="word-wrapping.html"><strong aria-hidden="true">8.</strong> Word Wrapping</a></li><li class="chapter-item expanded "><a href="entity-component-system.html"><strong aria-hidden="true">9.</strong> Entity Component System</a></li><li class="chapter-item expanded "><a href="game-data.html"><strong aria-hidden="true">10.</strong> Game Data</a></li><li class="chapter-item expanded "><a href="saving-and-loading.html"><strong aria-hidden="true">11.</strong> Saving and Loading</a></li><li class="chapter-item expanded "><a href="field-of-view.html"><strong aria-hidden="true">12.</strong> Field of View</a></li><li class="chapter-item expanded "><a href="pathfinding.html"><strong aria-hidden="true">13.</strong> Pathfinding</a></li><li class="chapter-item expanded "><a href="randomness.html"><strong aria-hidden="true">14.</strong> Randomness</a></li><li class="chapter-item expanded "><a href="map-generation.html"><strong aria-hidden="true">15.</strong> Map Generation</a></li><li class="chapter-item expanded "><a href="map-population.html"><strong aria-hidden="true">16.</strong> Map Population</a></li><li class="chapter-item expanded "><a href="auto-run.html"><strong aria-hidden="true">17.</strong> Auto-Run</a></li><li class="chapter-item expanded "><a href="turn-order-and-combat.html"><strong aria-hidden="true">18.</strong> Turn Order and Combat</a></li><li class="chapter-item expanded "><a href="items.html"><strong aria-hidden="true">19.</strong> Items</a></li><li class="chapter-item expanded "><a href="hunger-and-regeneration.html"><strong aria-hidden="true">20.</strong> Hunger and Regeneration</a></li><li class="chapter-item expanded "><a href="experience-and-difficulty.html"><strong aria-hidden="true">21.</strong> Experience and Difficulty</a></li><li class="chapter-item expanded "><a href="monsters.html"><strong aria-hidden="true">22.</strong> Monsters</a></li><li class="chapter-item expanded "><a href="new-game-plus.html"><strong aria-hidden="true">23.</strong> New Game Plus</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">RuggRogue Source Code Guide</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="user-interface"><a class="header" href="#user-interface">User Interface</a></h1>
<p>This chapter covers how RuggRogue handles menus and dialogs, the layout and drawing of the main game screen, and how application closing is handled.</p>
<h2 id="menus"><a class="header" href="#menus">Menus</a></h2>
<p>Most of RuggRogue's interface exists in the form of menus and dialogs.
As mentioned in the overall game flow chapter, menus and dialogs are represented as modes in the game's mode stack.
Because of this, there's no real difference between a &quot;menu&quot; and a &quot;dialog&quot;: they both present themselves as tile grids, react to player input and return some result.
This is a perfect excuse to demonstrate how menus work by using a dialog as an example instead.</p>
<p>The <code>YesNoDialogMode</code> struct in the <code>src/modes/yes_no_dialog.rs</code> file is the simplest dialog, and therefore the simplest menu, in the game.
The struct itself contains the <code>prompt</code> field that is shown to the player and a <code>yes_selected</code> boolean that the player can change by pressing keys.
Every menu and dialog holds data like this: one or more fields related to presentation, and a selection that represents a player-controlled cursor.
Sometimes this selection will be accompanied by a <code>subsection</code> field for more complex menus; the <code>YesNoDialogMode</code> doesn't need one, so it doesn't have one.</p>
<p>Above the definition of <code>YesNoDialogMode</code> is the <code>YesNoDialogModeResult</code> enum.
When the <code>YesNoDialogMode</code> is closed, it returns an instance of <code>YesNoDialogModeResult</code> to the mode immediately below it in the mode stack.
There are three variants: <code>Yes</code>, <code>No</code> and <code>AppQuit</code>.
The first two variants should be obvious; the <code>AppQuit</code> variant is explained in the <a href="event-handling.html#the-appquit-event">Event Handling chapter</a>.</p>
<p>If the game wants to show a yes-or-no prompt, it has to create a <code>YesNoDialogMode</code> using the <code>YesNoDialogMode::new</code> function.
There's an example of this when the player chooses to &quot;save and exit&quot; in the options menu.
This corresponds to the <code>OptionsMenuMode</code> in <code>src/modes/options_menu.rs</code>; look for the &quot;Save and return to title screen&quot; message near the end of the <code>OptionsMenuMode::update</code> function.
There are two important things that need to be done to show a yes-or-no prompt:</p>
<ol>
<li>Create a <code>ModeControl::Push</code> with an instance of <code>YesNoDialogMode</code> created with the <code>YesNoDialogMode::new</code> function.</li>
<li>Clear the input queue using <code>inputs.clear_input()</code> followed by <code>ModeUpdate::Immediate</code> for same-frame result handling while avoiding double-handling of keys.</li>
</ol>
<p>The mode stack will then take the <code>YesNoDialogMode</code> that was wrapped in the <code>ModeControl::Push</code> return value, add it to the mode stack and prepare a fresh <code>TileGridLayer</code> for it.</p>
<p>Once a mode is present in the mode stack, it calls these mode-related functions in order:</p>
<ol>
<li><code>prepare_grids</code></li>
<li><code>update</code>, if the mode is at the top of the stack</li>
<li><code>draw</code></li>
</ol>
<p>Back in <code>src/modes/yes_no_dialog.rs</code>, the <code>YesNoDialogMode::prepare_grids</code> function is the very first function that is called when the <code>YesNoDialogMode</code> is on the stack.
This ensures that the <code>update</code> and <code>draw</code> functions have the same view of the screen and tile grids on any given frame.
The first thing this function does is calculate the dimensions of the tile grid it wants to draw in, whether or not such a tile grid even exists yet.
On the very first call, the vector of <code>TileGrid</code>s corresponding to the <code>TileGridLayer</code> assigned to the mode is empty, so the <code>YesNoDialogMode::prepare_grids</code> function will create a fresh <code>TileGrid</code> with the desired dimensions.
On subsequent calls that tile grid will already exist, so it will just be resized instead.
The <code>YesNoDialogMode::prepare_grids</code> function wraps up by setting its tileset, position (<code>TileGrid::view_centered</code> is a helper to adjust the <code>TileGridView</code>) and zoom factor.
The fact that this information is calculated and assigned every frame is what allows the options menu to instantly take effect on the entire interface.</p>
<p>The <code>YesNoDialogMode::update</code> function is how the dialog responds to player input.
First, an input is pulled in from the input queue by calling the <code>input.prepare_input</code> function.
Next, that input event is read out by calling the <code>input.get_input</code> function.
Assuming it's a key press event, it is then translated into a logical game key by calling the <code>gamekey::from_keycode</code> function.
The <code>YesNoDialogMode::update</code> function reacts to <code>GameKey::Left</code> and <code>GameKey::Right</code> by altering the selected option.</p>
<p>The <code>YesNoDialogMode::draw</code> function draws the dialog itself.
The first thing it does is dim itself if it's not the top-most mode on the stack by setting <code>color_mod</code> to <code>Color::GRAY</code> in response to the value of the <code>active</code> parameter.
The drawing itself takes place after that, drawing the box border and message.
When drawing the &quot;Yes&quot; and &quot;No&quot; options, it reads the <code>yes_selected</code> field of the mode to highlight whichever option the player currently has selected.</p>
<p>Eventually the player will pick either the &quot;Yes&quot; or &quot;No&quot; options.
This is picked up in the <code>YesNoDialogMode::update</code> function when it receives <code>GameKey::Confirm</code> or <code>GameKey::Cancel</code> as a input key.
At this point, the <code>YesNoDialogMode</code> will create an instance of either <code>YesNoDialogModeResult::Yes</code> or <code>YesNoDialogModeResult::No</code>, and wrap it in <code>ModeControl::Pop</code> to tell the mode stack to pop the <code>YesNoDialogMode</code> and send the <code>YesNoDialogModeResult</code> to whatever mode pushed it on to begin with.</p>
<p>This takes us back to the &quot;save and exit&quot; logic in the <code>OptionsMenuMode::update</code> function in <code>src/modes/options_menu.rs</code> file.
The <code>YesNoDialogModeResult</code> will be received in the <code>pop_result</code> parameter of the <code>OptionsMenuMode::update</code> function, and then responded to in the block starting with <code>if let Some(result) = pop_result</code>.
In this case, <code>OptionsMenuMode</code> responds to <code>YesNoDialogModeResult::Yes</code> by popping itself off the mode stack with its own <code>OptionsMenuModeResult::ReallyQuit</code> value.</p>
<p>This covers the entire life-cycle of a yes-or-no dialog:</p>
<ol>
<li>A mode that wants a yes-or-no dialog creates a <code>YesNoDialogMode</code> instance that gets pushed onto the mode stack.</li>
<li>The <code>YesNoDialogMode::prepare_grids</code> function is called to create a tile grid or adjust an existing one.</li>
<li><code>YesNoDialogMode::update</code> responds to player inputs.</li>
<li><code>YesNoDialogMode::draw</code> draws the dialog itself.</li>
<li><code>YesNoDialogMode::update</code> eventually pops itself off the mode stack with an instance of <code>YesNoDialogModeResult</code>.</li>
<li>The original mode beneath catches the <code>YesNoDialogModeResult</code> and reacts to it.</li>
</ol>
<p>This life-cycle is the foundation of every single dialog and menu in the game, even the <code>InventoryMode</code>, found in the <code>src/modes/inventory.rs</code> and the biggest of all the menus.</p>
<h2 id="the-main-game-screen"><a class="header" href="#the-main-game-screen">The Main Game Screen</a></h2>
<p>The majority of the gameplay takes place in <code>DungeonMode</code>, which can be found in the <code>src/modes/dungeon.rs</code> file.
It is responsible for handling player control, distributing turns and drawing the main game interface.
This section describes how the interface is laid out and drawn; player control and turn order will be covered in a later chapter.</p>
<p>The main game screen consists of multiple tile grids that the dungeon mode creates in its mode-stack-designated tile grid layer:</p>
<ol>
<li>The <em>map grid</em> that shows the dungeon map, the player, items and monsters.</li>
<li>The <em>status grid</em> that shows the player's status information, such as their level, health, hunger and turns.</li>
<li>The <em>item grid</em> that shows the player's equipment and number of carried inventory items.</li>
<li>The <em>message frame grid</em> that draws a border around the message log.</li>
<li>The <em>message grid</em> that shows the message log.</li>
</ol>
<p>The distinction between the message frame grid and the message grid is a bit janky.
The split was part of a plan to use wrapped offset rendering to increase message rendering performance, but it never ended up happening.
If I were to revisit this part of the code I would just have a single message grid that draws its frame like everything else.</p>
<p>The <code>DungeonMode::new</code> function prepares the book-keeping for the dungeon mode, the most important part of which is for chunked map drawing, described in detail back in the <a href="rendering.html#improving-map-drawing-performance-with-chunked-drawing">Rendering chapter</a>.</p>
<p>Things get slightly more interesting with the <code>DungeonMode::prepare_grids</code> function, which immediately delegates all of its work to the <code>ui::prepare_grids</code> function.
This function can be found at the very bottom of the <code>src/ui.rs</code> file, and is responsible for calculating and setting the size and position of all the main game screen tile grids.
Despite living in a separate file, it serves the same function as any code found in the <code>prepare_grids</code> function of any other mode.
After setting the size of the map grid, it calls the <code>ChunkedMapGrid::prepare_grid</code> function so that it can prepare and adjust itself to the map tile grid and screen dimensions.</p>
<p>Back in <code>src/modes/dungeon.rs</code>, the <code>DungeonMode::draw</code> function is responsible for coordinating the drawing of all the main game screen tile grids.
Pretty much all of the drawing is delegated here as well.
The <code>ChunkedMapGrid::draw</code> function renders the map itself, while entities on the map are drawn via the <code>render::draw_renderables</code> function, defined in the <code>src/render.rs</code> file.
All of the sidebar tile grids are drawn via the <code>ui::draw_ui</code> function, found in the <code>src/ui.rs</code> file.
The <code>ui::draw_ui</code> function in turn calls the <code>draw_status</code>, <code>draw_item_info</code> and <code>draw_messages</code> functions to fill out each of the grids.
The <code>draw_messages</code> function in particular applies word wrapping to message lines; this is covered in its own chapter.</p>
<p>Apart from <code>DungeonMode</code>, there are two other modes that also draw the main game screen in this fashion: <code>TargetMode</code> and <code>ViewMapMode</code>.
<code>TargetMode</code> is defined in <code>src/modes/target.rs</code> and allows the player to pick a target tile when using an item that needs a target.
<code>ViewMapMode</code> is defined in <code>src/modes/view_map.rs</code> and allows the player to pan the camera while describing map tiles.
Both of these modes show dynamically-updating text in the message area by filling in the optional <code>prompt</code> parameter when calling the <code>ui::draw_ui</code> function.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="rendering.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="options.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="rendering.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="options.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
