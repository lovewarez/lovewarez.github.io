<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Word Wrapping - RuggRogue Source Code Guide</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Design and source code breakdown of a simple roguelike">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="book/outlink.css">

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Introduction</a></li><li class="chapter-item expanded "><a href="dependencies.html"><strong aria-hidden="true">1.</strong> Dependencies</a></li><li class="chapter-item expanded "><a href="source-code-layout.html"><strong aria-hidden="true">2.</strong> Source Code Layout</a></li><li class="chapter-item expanded "><a href="overall-game-flow.html"><strong aria-hidden="true">3.</strong> Overall Game Flow</a></li><li class="chapter-item expanded "><a href="event-handling.html"><strong aria-hidden="true">4.</strong> Event Handling</a></li><li class="chapter-item expanded "><a href="rendering.html"><strong aria-hidden="true">5.</strong> Rendering</a></li><li class="chapter-item expanded "><a href="user-interface.html"><strong aria-hidden="true">6.</strong> User Interface</a></li><li class="chapter-item expanded "><a href="options.html"><strong aria-hidden="true">7.</strong> Options</a></li><li class="chapter-item expanded "><a href="word-wrapping.html" class="active"><strong aria-hidden="true">8.</strong> Word Wrapping</a></li><li class="chapter-item expanded "><a href="entity-component-system.html"><strong aria-hidden="true">9.</strong> Entity Component System</a></li><li class="chapter-item expanded "><a href="game-data.html"><strong aria-hidden="true">10.</strong> Game Data</a></li><li class="chapter-item expanded "><a href="saving-and-loading.html"><strong aria-hidden="true">11.</strong> Saving and Loading</a></li><li class="chapter-item expanded "><a href="field-of-view.html"><strong aria-hidden="true">12.</strong> Field of View</a></li><li class="chapter-item expanded "><a href="pathfinding.html"><strong aria-hidden="true">13.</strong> Pathfinding</a></li><li class="chapter-item expanded "><a href="randomness.html"><strong aria-hidden="true">14.</strong> Randomness</a></li><li class="chapter-item expanded "><a href="map-generation.html"><strong aria-hidden="true">15.</strong> Map Generation</a></li><li class="chapter-item expanded "><a href="map-population.html"><strong aria-hidden="true">16.</strong> Map Population</a></li><li class="chapter-item expanded "><a href="auto-run.html"><strong aria-hidden="true">17.</strong> Auto-Run</a></li><li class="chapter-item expanded "><a href="turn-order-and-combat.html"><strong aria-hidden="true">18.</strong> Turn Order and Combat</a></li><li class="chapter-item expanded "><a href="items.html"><strong aria-hidden="true">19.</strong> Items</a></li><li class="chapter-item expanded "><a href="hunger-and-regeneration.html"><strong aria-hidden="true">20.</strong> Hunger and Regeneration</a></li><li class="chapter-item expanded "><a href="experience-and-difficulty.html"><strong aria-hidden="true">21.</strong> Experience and Difficulty</a></li><li class="chapter-item expanded "><a href="monsters.html"><strong aria-hidden="true">22.</strong> Monsters</a></li><li class="chapter-item expanded "><a href="new-game-plus.html"><strong aria-hidden="true">23.</strong> New Game Plus</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">RuggRogue Source Code Guide</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="word-wrapping"><a class="header" href="#word-wrapping">Word Wrapping</a></h1>
<p>If you play RuggRogue, you'll notice the messages that appear in the sidebar.
There's enough room for messages up to 32 characters long to appear unbroken; anything longer than that must be <em>word wrapped</em>.
Word wrapping is the act of breaking a long line down into a sequence of shorter lines that fit inside a desired width while keeping words whole.</p>
<p>All of RuggRogue's word wrapping is done by the <code>ruggrogue::word_wrap</code> function in the <code>src/lib/word_wrap.rs</code> file.
If you're not used to Rust's iterator system, the logic might be hard to follow, so I'm going to do something a bit different here than in the rest of the book: we're going to build the whole thing from the ground up!
This chapter contains runnable code samples; press the &quot;play&quot; button in the top corner to build and run the examples (they get fed through the <a href="https://play.rust-lang.org/">Rust Playground</a>).
If you get time-outs, there's a button to copy the code to the clipboard, and you can paste that into a file and throw it at <code>rustc</code> to run the demo if you have Rust installed.</p>
<p>Before we start, read the <a href="https://doc.rust-lang.org/stable/book/ch13-02-iterators.html">iterators chapter of the Rust book</a>.
No, really, I'll wait; you'll want to be familiar with Rust's iterators before continuing.</p>
<p>...</p>
<p>Okay, now that you've read that (or not), the key take-away is this idea of <em>iterator adaptors</em>: functions that take an existing iterator and produces a new one that adds their own processing to the end.
The job of the <code>ruggrogue::word_wrap</code> function is to create an iterator that takes a string slice (a reference to a sequence of characters in a string) and produces multiple string slices that all fit within a given width.
RuggRogue prints these word-wrapped strings onto tile grids, so the width here is measured as the number of characters per line.</p>
<p>Broadly speaking, the <code>ruggrogue::word_wrap</code> function creates an iterator that does the following:</p>
<ol>
<li>Break the input string into lines based on any existing line break characters in the string itself.</li>
<li>Break each line down into characters and their byte offsets (all Rust strings are UTF-8 encoded).</li>
<li>Prepare the characters and byte offsets for word scanning.</li>
<li>Scan for words, emitting the byte offsets of whole words and individual whitespace characters.</li>
<li>Prepare the word and whitespace byte offset data for line building.</li>
<li>Build line data by fitting a sequence of whitespaces followed by a word onto the current line if it fits, or starting a new line with only the word if it doesn't.</li>
<li>Convert the line data back into strings.</li>
</ol>
<h2 id="step-1-break-on-existing-lines"><a class="header" href="#step-1-break-on-existing-lines">Step 1: Break on Existing Lines</a></h2>
<p>This all starts really basic: we need a function that takes an input string and a maximum character width, and returns an iterator.
To see the results of all of this, we need some sample input and some output logic, maybe something like this:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let max_length = 15;
    let msg = &quot;  I'm nöbödy!  Whö are yöu?
Are yöu nöbödy, töö?
Then there's a pair of us - don't tell!
They'd banish us, you know.

  How dreary to be somebody!
How public, li-ke a ƒrog
To tell your name the live-long day
To an admiring bog!

  - nobody&quot;;

    for tmp in word_wrap(msg, max_length) {
        println!(&quot;{:?}&quot;, tmp);
    }
}

fn word_wrap(input: &amp;str, max_length: usize) -&gt; impl Iterator&lt;Item = &amp;str&gt; {
    assert!(max_length &gt; 0);

    input.lines()
}
</code></pre></pre>
<p>I've taken the liberty of throwing in some random non-ASCII characters to ensure that we're handling the difference between bytes and characters, as you have to when handling UTF-8 encoded strings.
You should see the input string just being broken into the lines using Rust's <a href="https://doc.rust-lang.org/std/primitive.str.html#method.lines"><code>str::lines</code></a> function, which returns a simple iterator that does just that.
Rust's <code>for</code> loops automatically understand iterators, so that's what the main function does to produce its output.</p>
<p>From here on, we'll leave out the <code>main</code> function to focus on the <code>word_wrap</code> function that we're building up, but it will still be there when you run the code samples.
There's a toggle button in the top right of these samples to show the full demo code if you want to see it.</p>
<h2 id="step-2-characters-and-byte-offsets"><a class="header" href="#step-2-characters-and-byte-offsets">Step 2: Characters and Byte Offsets</a></h2>
<p>In order to perform word wrapping we'll need to know how each line breaks down into characters, so we know what's whitespace and what belongs to a word.
We'll also need the byte offsets of each of these characters, which can be larger than a single byte if they're not in the ASCII character range.
The byte offsets will be used to create the final string slices that refer back to the original input string data; we don't want to allocate string storage to replicate parts of strings that already exist!</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let max_length = 15;
</span><span class="boring">    let msg = &quot;  I'm nöbödy!  Whö are yöu?
</span><span class="boring">Are yöu nöbödy, töö?
</span><span class="boring">Then there's a pair of us - don't tell!
</span><span class="boring">They'd banish us, you know.
</span><span class="boring">
</span><span class="boring">  How dreary to be somebody!
</span><span class="boring">How public, li-ke a ƒrog
</span><span class="boring">To tell your name the live-long day
</span><span class="boring">To an admiring bog!
</span><span class="boring">
</span><span class="boring">  - nobody&quot;;
</span><span class="boring">
</span><span class="boring">    for tmp in word_wrap(msg, max_length) {
</span><span class="boring">        println!(&quot;{:?}&quot;, tmp);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn word_wrap(input: &amp;str, max_length: usize) -&gt; impl Iterator&lt;Item = (usize, char)&gt; + '_ {
</span><span class="boring">    assert!(max_length &gt; 0);
</span><span class="boring">
</span>    input.lines().flat_map(move |line| {
        line.char_indices()
    })
<span class="boring">}
</span></code></pre></pre>
<p>Running the above sample should print a long list of characters and their byte offsets.</p>
<p>Rust's <a href="https://doc.rust-lang.org/std/primitive.str.html#method.char_indices"><code>str::char_indices</code></a> gives us the characters and byte offsets that you'll see if you run the code sample.
This by itself would give us a nested iterator: one iterator of chars-and-offsets per line.
We use Rust's <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.flat_map"><code>Iterator::flat_map</code></a> function to remove this nesting to get ourselves a single long list of chars-and-offsets.
Note that the byte offsets shown are relative to the start of each line, not the input string as a whole.</p>
<h2 id="step-3-prepare-for-word-scanning"><a class="header" href="#step-3-prepare-for-word-scanning">Step 3: Prepare for Word Scanning</a></h2>
<p>The word scanning that we're going to do next is done a character at a time, but we need to perform some finalization at the end.
But iterators in Rust only do things on a per-item basis.
How do we get an iterator to do something <em>after</em> the last item?</p>
<p>We're going to use Rust's <a href="https://doc.rust-lang.org/std/option/enum.Option.html"><code>Option</code> type</a> to wrap each item inside a <code>Some</code> variant.
We'll then use <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.chain"><code>Iterator::chain</code></a> with a one-item iterator of the <code>None</code> variant using <a href="https://doc.rust-lang.org/std/iter/fn.once.html"><code>iter::once</code></a> to act as the final <em>sentinel</em> value.
Putting it together gives us something that looks like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let max_length = 15;
</span><span class="boring">    let msg = &quot;  I'm nöbödy!  Whö are yöu?
</span><span class="boring">Are yöu nöbödy, töö?
</span><span class="boring">Then there's a pair of us - don't tell!
</span><span class="boring">They'd banish us, you know.
</span><span class="boring">
</span><span class="boring">  How dreary to be somebody!
</span><span class="boring">How public, li-ke a ƒrog
</span><span class="boring">To tell your name the live-long day
</span><span class="boring">To an admiring bog!
</span><span class="boring">
</span><span class="boring">  - nobody&quot;;
</span><span class="boring">
</span><span class="boring">    for tmp in word_wrap(msg, max_length) {
</span><span class="boring">        println!(&quot;{:?}&quot;, tmp);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn word_wrap(input: &amp;str, max_length: usize) -&gt; impl Iterator&lt;Item = (usize, Option&lt;char&gt;)&gt; + '_ {
</span><span class="boring">    assert!(max_length &gt; 0);
</span><span class="boring">
</span>    input.lines().flat_map(move |line| {
        line.char_indices()
            .map(|(pos, ch)| (pos, Some(ch)))
            .chain(std::iter::once((line.len(), None))) // character sentinel
    })
<span class="boring">}
</span></code></pre></pre>
<p>Running the code sample should produce the same characters and offsets wrapped with <code>Some</code>, with a single <code>None</code> representing the end of each line.</p>
<h2 id="step-4-scan-for-words"><a class="header" href="#step-4-scan-for-words">Step 4: Scan for Words</a></h2>
<p>Now that we have characters, offsets and a sentinel to mark the end of each line, how do we detect words?
For that we'll use Rust's <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.scan"><code>iter::scan</code></a> function.
I recommend reading its official documentation.
The idea here is that we want to step through each character, building up memory of where each word begins, and the previous character to detect where each word should end.
We also treat hyphens as the end of a word, and break any words that exceed the maximum line width.
Every time we detect the end of a word, we need to emit data with <code>Some</code>, otherwise we'll emit a <code>None</code> to indicate that we're still processing characters.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let max_length = 15;
</span><span class="boring">    let msg = &quot;  I'm nöbödy!  Whö are yöu?
</span><span class="boring">Are yöu nöbödy, töö?
</span><span class="boring">Then there's a pair of us - don't tell!
</span><span class="boring">They'd banish us, you know.
</span><span class="boring">
</span><span class="boring">  How dreary to be somebody!
</span><span class="boring">How public, li-ke a ƒrog
</span><span class="boring">To tell your name the live-long day
</span><span class="boring">To an admiring bog!
</span><span class="boring">
</span><span class="boring">  - nobody&quot;;
</span><span class="boring">
</span><span class="boring">    for tmp in word_wrap(msg, max_length) {
</span><span class="boring">        println!(&quot;{:?}&quot;, tmp);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn word_wrap(input: &amp;str, max_length: usize) -&gt; impl Iterator&lt;Item = Option&lt;(usize, usize, usize, bool)&gt;&gt; + '_ {
</span><span class="boring">    assert!(max_length &gt; 0);
</span><span class="boring">
</span>    input.lines().flat_map(move |line| {
        line.char_indices()
            .map(|(pos, ch)| (pos, Some(ch)))
            .chain(std::iter::once((line.len(), None))) // character sentinel
            .scan(None, move |state, (pos, ch)| {
                // Break into words and single spaces.
                if let Some(ch) = ch {
                    if let Some((in_word, start_pos, char_count, last_char)) = state {
                        if *char_count &gt;= max_length || *last_char == '-' || ch.is_whitespace() {
                            // Line-length or hyphen-divided word, or mid-line whitespace.
                            let was_word = *in_word;
                            let last_start_pos = *start_pos;
                            let last_char_count = *char_count;
                            *in_word = !ch.is_whitespace();
                            *start_pos = pos;
                            *char_count = 1;
                            *last_char = ch;
                            Some(Some((last_start_pos, pos, last_char_count, was_word)))
                        } else if *in_word {
                            // Word continuation.
                            *char_count += 1;
                            *last_char = ch;
                            Some(None)
                        } else {
                            // Entering a word after whitespace.
                            let was_word = *in_word;
                            let last_start_pos = *start_pos;
                            let last_char_count = *char_count;
                            *in_word = true;
                            *start_pos = pos;
                            *char_count = 1;
                            *last_char = ch;
                            Some(Some((last_start_pos, pos, last_char_count, was_word)))
                        }
                    } else {
                        // Start of the line.
                        let in_word = !ch.is_whitespace();
                        let start_pos = pos;
                        let char_count = 1;
                        let last_char = ch;
                        *state = Some((in_word, start_pos, char_count, last_char));
                        Some(None)
                    }
                } else {
                    // End of the line.
                    if let Some((in_word, start_pos, char_count, _)) = state {
                        // Finish the final word or whitespace.
                        Some(Some((*start_pos, pos, *char_count, *in_word)))
                    } else {
                        // Empty line.
                        Some(Some((pos, pos, 0, false)))
                    }
                }
            })
    })
<span class="boring">}
</span></code></pre></pre>
<p>If you run the above code, you'll see that the output is a mixture of <code>Some</code> and <code>None</code> variants.
The <code>None</code>s represent intermediate working steps when a character is scanned but a word or whitespace hasn't been fully processed yet.
The <code>Some</code> means a whole word or single whitespace character has been processed.
The <code>Some</code> holds a 4-tuple consisting of three numbers and boolean flag.
The first two numbers are the byte offset of the start (inclusive) and end (exclusive) of each word or whitespace character.
The third number is the length of the word, in characters.
The boolean is <code>true</code> when it represents a word, or <code>false</code> for a whitespace character.</p>
<p>Note the bottom of the code that picks up the <code>None</code> sentinel value at the end of the line to finish the last word or whitespace character.</p>
<h2 id="step-5-prepare-for-line-scanning"><a class="header" href="#step-5-prepare-for-line-scanning">Step 5: Prepare for Line Scanning</a></h2>
<p>In order to build characters up into words, we needed to wrap each value with <code>Some</code> and add a <code>None</code> sentinel value.
We need to perform scanning again, this time for words.
If you ran the previous code sample, you'll notice that our data is already wrapped up in <code>Some</code>, but there's a lot of <code>None</code> values mixed in there.
We're going to use <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.filter"><code>iter::filter</code></a> along with <a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.is_some"><code>Option::is_some</code></a> to clear out those <code>None</code> values.
We'd also like to re-add that single <code>None</code> value to mark the end of the line again to handle the final word or whitespace after we perform line scanning.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let max_length = 15;
</span><span class="boring">    let msg = &quot;  I'm nöbödy!  Whö are yöu?
</span><span class="boring">Are yöu nöbödy, töö?
</span><span class="boring">Then there's a pair of us - don't tell!
</span><span class="boring">They'd banish us, you know.
</span><span class="boring">
</span><span class="boring">  How dreary to be somebody!
</span><span class="boring">How public, li-ke a ƒrog
</span><span class="boring">To tell your name the live-long day
</span><span class="boring">To an admiring bog!
</span><span class="boring">
</span><span class="boring">  - nobody&quot;;
</span><span class="boring">
</span><span class="boring">    for tmp in word_wrap(msg, max_length) {
</span><span class="boring">        println!(&quot;{:?}&quot;, tmp);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn word_wrap(input: &amp;str, max_length: usize) -&gt; impl Iterator&lt;Item = Option&lt;(usize, usize, usize, bool)&gt;&gt; + '_ {
</span><span class="boring">    assert!(max_length &gt; 0);
</span><span class="boring">
</span>    input.lines().flat_map(move |line| {
        line.char_indices()
            .map(|(pos, ch)| (pos, Some(ch)))
            .chain(std::iter::once((line.len(), None))) // character sentinel
            .scan(None, move |state, (pos, ch)| {
                // Break into words and single spaces.
                // ...
<span class="boring">                if let Some(ch) = ch {
</span><span class="boring">                    if let Some((in_word, start_pos, char_count, last_char)) = state {
</span><span class="boring">                        if *char_count &gt;= max_length || *last_char == '-' || ch.is_whitespace() {
</span><span class="boring">                            // Line-length or hyphen-divided word, or mid-line whitespace.
</span><span class="boring">                            let was_word = *in_word;
</span><span class="boring">                            let last_start_pos = *start_pos;
</span><span class="boring">                            let last_char_count = *char_count;
</span><span class="boring">                            *in_word = !ch.is_whitespace();
</span><span class="boring">                            *start_pos = pos;
</span><span class="boring">                            *char_count = 1;
</span><span class="boring">                            *last_char = ch;
</span><span class="boring">                            Some(Some((last_start_pos, pos, last_char_count, was_word)))
</span><span class="boring">                        } else if *in_word {
</span><span class="boring">                            // Word continuation.
</span><span class="boring">                            *char_count += 1;
</span><span class="boring">                            *last_char = ch;
</span><span class="boring">                            Some(None)
</span><span class="boring">                        } else {
</span><span class="boring">                            // Entering a word after whitespace.
</span><span class="boring">                            let was_word = *in_word;
</span><span class="boring">                            let last_start_pos = *start_pos;
</span><span class="boring">                            let last_char_count = *char_count;
</span><span class="boring">                            *in_word = true;
</span><span class="boring">                            *start_pos = pos;
</span><span class="boring">                            *char_count = 1;
</span><span class="boring">                            *last_char = ch;
</span><span class="boring">                            Some(Some((last_start_pos, pos, last_char_count, was_word)))
</span><span class="boring">                        }
</span><span class="boring">                    } else {
</span><span class="boring">                        // Start of the line.
</span><span class="boring">                        let in_word = !ch.is_whitespace();
</span><span class="boring">                        let start_pos = pos;
</span><span class="boring">                        let char_count = 1;
</span><span class="boring">                        let last_char = ch;
</span><span class="boring">                        *state = Some((in_word, start_pos, char_count, last_char));
</span><span class="boring">                        Some(None)
</span><span class="boring">                    }
</span><span class="boring">                } else {
</span><span class="boring">                    // End of the line.
</span><span class="boring">                    if let Some((in_word, start_pos, char_count, _)) = state {
</span><span class="boring">                        // Finish the final word or whitespace.
</span><span class="boring">                        Some(Some((*start_pos, pos, *char_count, *in_word)))
</span><span class="boring">                    } else {
</span><span class="boring">                        // Empty line.
</span><span class="boring">                        Some(Some((pos, pos, 0, false)))
</span><span class="boring">                    }
</span><span class="boring">                }
</span>            })
            .filter(Option::is_some)
            .chain(Some(None)) // word sentinel
    })
<span class="boring">}
</span></code></pre></pre>
<p>The output should be the same as before, but with all of the <code>None</code> values gone, except for a final <code>None</code> to mark the end of each line.</p>
<h2 id="step-6-build-lines-by-scanning-words-and-whitespaces"><a class="header" href="#step-6-build-lines-by-scanning-words-and-whitespaces">Step 6: Build Lines by Scanning Words and Whitespaces</a></h2>
<p>We now have everything we need to create a scanner that builds up lines.
The idea of this scanner is to extend a line continuously with a sequence of whitespace characters followed by a single word.
If the sum of the character counts of that sequence and the existing line fits in the desired width, we append the whole thing to the line.
If not, we'll emit the line as-is, and start a new line <em>without</em> the preceeding whitespace characters.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let max_length = 15;
</span><span class="boring">    let msg = &quot;  I'm nöbödy!  Whö are yöu?
</span><span class="boring">Are yöu nöbödy, töö?
</span><span class="boring">Then there's a pair of us - don't tell!
</span><span class="boring">They'd banish us, you know.
</span><span class="boring">
</span><span class="boring">  How dreary to be somebody!
</span><span class="boring">How public, li-ke a ƒrog
</span><span class="boring">To tell your name the live-long day
</span><span class="boring">To an admiring bog!
</span><span class="boring">
</span><span class="boring">  - nobody&quot;;
</span><span class="boring">
</span><span class="boring">    for tmp in word_wrap(msg, max_length) {
</span><span class="boring">        println!(&quot;{:?}&quot;, tmp);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn word_wrap(input: &amp;str, max_length: usize) -&gt; impl Iterator&lt;Item = Option&lt;(usize, usize)&gt;&gt; + '_ {
</span><span class="boring">    assert!(max_length &gt; 0);
</span><span class="boring">
</span>    input.lines().flat_map(move |line| {
        line.char_indices()
            .map(|(pos, ch)| (pos, Some(ch)))
            .chain(std::iter::once((line.len(), None))) // character sentinel
            .scan(None, move |state, (pos, ch)| {
                // Break into words and single spaces.
                // ...
<span class="boring">                if let Some(ch) = ch {
</span><span class="boring">                    if let Some((in_word, start_pos, char_count, last_char)) = state {
</span><span class="boring">                        if *char_count &gt;= max_length || *last_char == '-' || ch.is_whitespace() {
</span><span class="boring">                            // Line-length or hyphen-divided word, or mid-line whitespace.
</span><span class="boring">                            let was_word = *in_word;
</span><span class="boring">                            let last_start_pos = *start_pos;
</span><span class="boring">                            let last_char_count = *char_count;
</span><span class="boring">                            *in_word = !ch.is_whitespace();
</span><span class="boring">                            *start_pos = pos;
</span><span class="boring">                            *char_count = 1;
</span><span class="boring">                            *last_char = ch;
</span><span class="boring">                            Some(Some((last_start_pos, pos, last_char_count, was_word)))
</span><span class="boring">                        } else if *in_word {
</span><span class="boring">                            // Word continuation.
</span><span class="boring">                            *char_count += 1;
</span><span class="boring">                            *last_char = ch;
</span><span class="boring">                            Some(None)
</span><span class="boring">                        } else {
</span><span class="boring">                            // Entering a word after whitespace.
</span><span class="boring">                            let was_word = *in_word;
</span><span class="boring">                            let last_start_pos = *start_pos;
</span><span class="boring">                            let last_char_count = *char_count;
</span><span class="boring">                            *in_word = true;
</span><span class="boring">                            *start_pos = pos;
</span><span class="boring">                            *char_count = 1;
</span><span class="boring">                            *last_char = ch;
</span><span class="boring">                            Some(Some((last_start_pos, pos, last_char_count, was_word)))
</span><span class="boring">                        }
</span><span class="boring">                    } else {
</span><span class="boring">                        // Start of the line.
</span><span class="boring">                        let in_word = !ch.is_whitespace();
</span><span class="boring">                        let start_pos = pos;
</span><span class="boring">                        let char_count = 1;
</span><span class="boring">                        let last_char = ch;
</span><span class="boring">                        *state = Some((in_word, start_pos, char_count, last_char));
</span><span class="boring">                        Some(None)
</span><span class="boring">                    }
</span><span class="boring">                } else {
</span><span class="boring">                    // End of the line.
</span><span class="boring">                    if let Some((in_word, start_pos, char_count, _)) = state {
</span><span class="boring">                        // Finish the final word or whitespace.
</span><span class="boring">                        Some(Some((*start_pos, pos, *char_count, *in_word)))
</span><span class="boring">                    } else {
</span><span class="boring">                        // Empty line.
</span><span class="boring">                        Some(Some((pos, pos, 0, false)))
</span><span class="boring">                    }
</span><span class="boring">                }
</span>            })
            .filter(Option::is_some)
            .chain(Some(None)) // word sentinel
            .scan(None, move |state, word_data| {
                // Build up lines up to max_length.
                if let Some((word_start, word_end, word_char_count, is_word)) = word_data {
                    if let Some((line_start, line_end, final_end, line_char_count)) = state {
                        if is_word {
                            if *line_char_count + word_char_count &lt;= max_length {
                                // Word fits on line, so include it.
                                *line_end = word_end;
                                *final_end = word_end;
                                *line_char_count += word_char_count;
                                Some(None)
                            } else {
                                // Word exceeds line, so start a new line with it instead.
                                let last_line_start = *line_start;
                                let last_line_end = *line_end;
                                *line_start = word_start;
                                *line_end = word_end;
                                *final_end = word_end;
                                *line_char_count = word_char_count;
                                Some(Some((last_line_start, last_line_end)))
                            }
                        } else {
                            if *line_char_count + word_char_count &lt;= max_length {
                                // Whitespace fits on line, so include it when finishing words.
                                *final_end = word_end;
                            }
                            *line_char_count += word_char_count;
                            Some(None)
                        }
                    } else {
                        // The first word.
                        let line_start = word_start;
                        let line_end = if is_word { word_end } else { word_start };
                        let final_end = word_end;
                        let line_char_count = word_char_count;
                        *state = Some((line_start, line_end, final_end, line_char_count));
                        Some(None)
                    }
                } else {
                    // End of words.
                    if let Some((line_start, _, final_end, _)) = state {
                        // Finish the line.
                        Some(Some((*line_start, *final_end)))
                    } else {
                        // Empty line.
                        Some(Some((0, 0)))
                    }
                }
            })
    })
<span class="boring">}
</span></code></pre></pre>
<p>Running the above sample code will output just the byte offsets of the start (inclusive) and end (exclusive) of each wrapped line.
All those <code>Some</code> and <code>None</code> values are littered in there, and at this point we really only need the data inside each <code>Some</code>.
There's a trick we can do here: Rust can treat an <code>Option</code> like a container that has no items (<code>None</code>) or a single item (<code>Some(...)</code>).
What's more, Rust can convert an <code>Option</code> into an iterator, so if we squint hard enough, we sort of have a list of <em>iterators</em>.
We can therefore use the <code>iter::flatten</code> function to clean out the <code>None</code> values and extract the data from the <code>Some</code> variants in one fell swoop!</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let max_length = 15;
</span><span class="boring">    let msg = &quot;  I'm nöbödy!  Whö are yöu?
</span><span class="boring">Are yöu nöbödy, töö?
</span><span class="boring">Then there's a pair of us - don't tell!
</span><span class="boring">They'd banish us, you know.
</span><span class="boring">
</span><span class="boring">  How dreary to be somebody!
</span><span class="boring">How public, li-ke a ƒrog
</span><span class="boring">To tell your name the live-long day
</span><span class="boring">To an admiring bog!
</span><span class="boring">
</span><span class="boring">  - nobody&quot;;
</span><span class="boring">
</span><span class="boring">    for tmp in word_wrap(msg, max_length) {
</span><span class="boring">        println!(&quot;{:?}&quot;, tmp);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn word_wrap(input: &amp;str, max_length: usize) -&gt; impl Iterator&lt;Item = (usize, usize)&gt; + '_ {
</span><span class="boring">    assert!(max_length &gt; 0);
</span><span class="boring">
</span>    input.lines().flat_map(move |line| {
        line.char_indices()
            .map(|(pos, ch)| (pos, Some(ch)))
            .chain(std::iter::once((line.len(), None))) // character sentinel
            .scan(None, move |state, (pos, ch)| {
                // Break into words and single spaces.
                // ...
<span class="boring">                if let Some(ch) = ch {
</span><span class="boring">                    if let Some((in_word, start_pos, char_count, last_char)) = state {
</span><span class="boring">                        if *char_count &gt;= max_length || *last_char == '-' || ch.is_whitespace() {
</span><span class="boring">                            // Line-length or hyphen-divided word, or mid-line whitespace.
</span><span class="boring">                            let was_word = *in_word;
</span><span class="boring">                            let last_start_pos = *start_pos;
</span><span class="boring">                            let last_char_count = *char_count;
</span><span class="boring">                            *in_word = !ch.is_whitespace();
</span><span class="boring">                            *start_pos = pos;
</span><span class="boring">                            *char_count = 1;
</span><span class="boring">                            *last_char = ch;
</span><span class="boring">                            Some(Some((last_start_pos, pos, last_char_count, was_word)))
</span><span class="boring">                        } else if *in_word {
</span><span class="boring">                            // Word continuation.
</span><span class="boring">                            *char_count += 1;
</span><span class="boring">                            *last_char = ch;
</span><span class="boring">                            Some(None)
</span><span class="boring">                        } else {
</span><span class="boring">                            // Entering a word after whitespace.
</span><span class="boring">                            let was_word = *in_word;
</span><span class="boring">                            let last_start_pos = *start_pos;
</span><span class="boring">                            let last_char_count = *char_count;
</span><span class="boring">                            *in_word = true;
</span><span class="boring">                            *start_pos = pos;
</span><span class="boring">                            *char_count = 1;
</span><span class="boring">                            *last_char = ch;
</span><span class="boring">                            Some(Some((last_start_pos, pos, last_char_count, was_word)))
</span><span class="boring">                        }
</span><span class="boring">                    } else {
</span><span class="boring">                        // Start of the line.
</span><span class="boring">                        let in_word = !ch.is_whitespace();
</span><span class="boring">                        let start_pos = pos;
</span><span class="boring">                        let char_count = 1;
</span><span class="boring">                        let last_char = ch;
</span><span class="boring">                        *state = Some((in_word, start_pos, char_count, last_char));
</span><span class="boring">                        Some(None)
</span><span class="boring">                    }
</span><span class="boring">                } else {
</span><span class="boring">                    // End of the line.
</span><span class="boring">                    if let Some((in_word, start_pos, char_count, _)) = state {
</span><span class="boring">                        // Finish the final word or whitespace.
</span><span class="boring">                        Some(Some((*start_pos, pos, *char_count, *in_word)))
</span><span class="boring">                    } else {
</span><span class="boring">                        // Empty line.
</span><span class="boring">                        Some(Some((pos, pos, 0, false)))
</span><span class="boring">                    }
</span><span class="boring">                }
</span>            })
            .filter(Option::is_some)
            .chain(Some(None)) // word sentinel
            .scan(None, move |state, word_data| {
                // Build up lines up to max_length.
                // ...
<span class="boring">                if let Some((word_start, word_end, word_char_count, is_word)) = word_data {
</span><span class="boring">                    if let Some((line_start, line_end, final_end, line_char_count)) = state {
</span><span class="boring">                        if is_word {
</span><span class="boring">                            if *line_char_count + word_char_count &lt;= max_length {
</span><span class="boring">                                // Word fits on line, so include it.
</span><span class="boring">                                *line_end = word_end;
</span><span class="boring">                                *final_end = word_end;
</span><span class="boring">                                *line_char_count += word_char_count;
</span><span class="boring">                                Some(None)
</span><span class="boring">                            } else {
</span><span class="boring">                                // Word exceeds line, so start a new line with it instead.
</span><span class="boring">                                let last_line_start = *line_start;
</span><span class="boring">                                let last_line_end = *line_end;
</span><span class="boring">                                *line_start = word_start;
</span><span class="boring">                                *line_end = word_end;
</span><span class="boring">                                *final_end = word_end;
</span><span class="boring">                                *line_char_count = word_char_count;
</span><span class="boring">                                Some(Some((last_line_start, last_line_end)))
</span><span class="boring">                            }
</span><span class="boring">                        } else {
</span><span class="boring">                            if *line_char_count + word_char_count &lt;= max_length {
</span><span class="boring">                                // Whitespace fits on line, so include it when finishing words.
</span><span class="boring">                                *final_end = word_end;
</span><span class="boring">                            }
</span><span class="boring">                            *line_char_count += word_char_count;
</span><span class="boring">                            Some(None)
</span><span class="boring">                        }
</span><span class="boring">                    } else {
</span><span class="boring">                        // The first word.
</span><span class="boring">                        let line_start = word_start;
</span><span class="boring">                        let line_end = if is_word { word_end } else { word_start };
</span><span class="boring">                        let final_end = word_end;
</span><span class="boring">                        let line_char_count = word_char_count;
</span><span class="boring">                        *state = Some((line_start, line_end, final_end, line_char_count));
</span><span class="boring">                        Some(None)
</span><span class="boring">                    }
</span><span class="boring">                } else {
</span><span class="boring">                    // End of words.
</span><span class="boring">                    if let Some((line_start, _, final_end, _)) = state {
</span><span class="boring">                        // Finish the line.
</span><span class="boring">                        Some(Some((*line_start, *final_end)))
</span><span class="boring">                    } else {
</span><span class="boring">                        // Empty line.
</span><span class="boring">                        Some(Some((0, 0)))
</span><span class="boring">                    }
</span><span class="boring">                }
</span>            })
            .flatten()
    })
<span class="boring">}
</span></code></pre></pre>
<p>Running the above code sample should produce a cleaned-up version of the output from the previous code sample.</p>
<h2 id="step-7-convert-data-back-into-string-slices"><a class="header" href="#step-7-convert-data-back-into-string-slices">Step 7: Convert Data back into String Slices</a></h2>
<p>We originally wanted string slices of word-wrapped lines, which trivially builds on the work that's been done up to this point.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let max_length = 15;
</span><span class="boring">    let msg = &quot;  I'm nöbödy!  Whö are yöu?
</span><span class="boring">Are yöu nöbödy, töö?
</span><span class="boring">Then there's a pair of us - don't tell!
</span><span class="boring">They'd banish us, you know.
</span><span class="boring">
</span><span class="boring">  How dreary to be somebody!
</span><span class="boring">How public, li-ke a ƒrog
</span><span class="boring">To tell your name the live-long day
</span><span class="boring">To an admiring bog!
</span><span class="boring">
</span><span class="boring">  - nobody&quot;;
</span><span class="boring">
</span><span class="boring">    for tmp in word_wrap(msg, max_length) {
</span><span class="boring">        println!(&quot;{:?}&quot;, tmp);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn word_wrap(input: &amp;str, max_length: usize) -&gt; impl Iterator&lt;Item = &amp;str&gt; {
</span><span class="boring">    assert!(max_length &gt; 0);
</span><span class="boring">
</span>    input.lines().flat_map(move |line| {
        line.char_indices()
            .map(|(pos, ch)| (pos, Some(ch)))
            .chain(std::iter::once((line.len(), None))) // character sentinel
            .scan(None, move |state, (pos, ch)| {
                // Break into words and single spaces.
                // ...
<span class="boring">                if let Some(ch) = ch {
</span><span class="boring">                    if let Some((in_word, start_pos, char_count, last_char)) = state {
</span><span class="boring">                        if *char_count &gt;= max_length || *last_char == '-' || ch.is_whitespace() {
</span><span class="boring">                            // Line-length or hyphen-divided word, or mid-line whitespace.
</span><span class="boring">                            let was_word = *in_word;
</span><span class="boring">                            let last_start_pos = *start_pos;
</span><span class="boring">                            let last_char_count = *char_count;
</span><span class="boring">                            *in_word = !ch.is_whitespace();
</span><span class="boring">                            *start_pos = pos;
</span><span class="boring">                            *char_count = 1;
</span><span class="boring">                            *last_char = ch;
</span><span class="boring">                            Some(Some((last_start_pos, pos, last_char_count, was_word)))
</span><span class="boring">                        } else if *in_word {
</span><span class="boring">                            // Word continuation.
</span><span class="boring">                            *char_count += 1;
</span><span class="boring">                            *last_char = ch;
</span><span class="boring">                            Some(None)
</span><span class="boring">                        } else {
</span><span class="boring">                            // Entering a word after whitespace.
</span><span class="boring">                            let was_word = *in_word;
</span><span class="boring">                            let last_start_pos = *start_pos;
</span><span class="boring">                            let last_char_count = *char_count;
</span><span class="boring">                            *in_word = true;
</span><span class="boring">                            *start_pos = pos;
</span><span class="boring">                            *char_count = 1;
</span><span class="boring">                            *last_char = ch;
</span><span class="boring">                            Some(Some((last_start_pos, pos, last_char_count, was_word)))
</span><span class="boring">                        }
</span><span class="boring">                    } else {
</span><span class="boring">                        // Start of the line.
</span><span class="boring">                        let in_word = !ch.is_whitespace();
</span><span class="boring">                        let start_pos = pos;
</span><span class="boring">                        let char_count = 1;
</span><span class="boring">                        let last_char = ch;
</span><span class="boring">                        *state = Some((in_word, start_pos, char_count, last_char));
</span><span class="boring">                        Some(None)
</span><span class="boring">                    }
</span><span class="boring">                } else {
</span><span class="boring">                    // End of the line.
</span><span class="boring">                    if let Some((in_word, start_pos, char_count, _)) = state {
</span><span class="boring">                        // Finish the final word or whitespace.
</span><span class="boring">                        Some(Some((*start_pos, pos, *char_count, *in_word)))
</span><span class="boring">                    } else {
</span><span class="boring">                        // Empty line.
</span><span class="boring">                        Some(Some((pos, pos, 0, false)))
</span><span class="boring">                    }
</span><span class="boring">                }
</span>            })
            .filter(Option::is_some)
            .chain(Some(None)) // word sentinel
            .scan(None, move |state, word_data| {
                // Build up lines up to max_length.
                // ...
<span class="boring">                if let Some((word_start, word_end, word_char_count, is_word)) = word_data {
</span><span class="boring">                    if let Some((line_start, line_end, final_end, line_char_count)) = state {
</span><span class="boring">                        if is_word {
</span><span class="boring">                            if *line_char_count + word_char_count &lt;= max_length {
</span><span class="boring">                                // Word fits on line, so include it.
</span><span class="boring">                                *line_end = word_end;
</span><span class="boring">                                *final_end = word_end;
</span><span class="boring">                                *line_char_count += word_char_count;
</span><span class="boring">                                Some(None)
</span><span class="boring">                            } else {
</span><span class="boring">                                // Word exceeds line, so start a new line with it instead.
</span><span class="boring">                                let last_line_start = *line_start;
</span><span class="boring">                                let last_line_end = *line_end;
</span><span class="boring">                                *line_start = word_start;
</span><span class="boring">                                *line_end = word_end;
</span><span class="boring">                                *final_end = word_end;
</span><span class="boring">                                *line_char_count = word_char_count;
</span><span class="boring">                                Some(Some((last_line_start, last_line_end)))
</span><span class="boring">                            }
</span><span class="boring">                        } else {
</span><span class="boring">                            if *line_char_count + word_char_count &lt;= max_length {
</span><span class="boring">                                // Whitespace fits on line, so include it when finishing words.
</span><span class="boring">                                *final_end = word_end;
</span><span class="boring">                            }
</span><span class="boring">                            *line_char_count += word_char_count;
</span><span class="boring">                            Some(None)
</span><span class="boring">                        }
</span><span class="boring">                    } else {
</span><span class="boring">                        // The first word.
</span><span class="boring">                        let line_start = word_start;
</span><span class="boring">                        let line_end = if is_word { word_end } else { word_start };
</span><span class="boring">                        let final_end = word_end;
</span><span class="boring">                        let line_char_count = word_char_count;
</span><span class="boring">                        *state = Some((line_start, line_end, final_end, line_char_count));
</span><span class="boring">                        Some(None)
</span><span class="boring">                    }
</span><span class="boring">                } else {
</span><span class="boring">                    // End of words.
</span><span class="boring">                    if let Some((line_start, _, final_end, _)) = state {
</span><span class="boring">                        // Finish the line.
</span><span class="boring">                        Some(Some((*line_start, *final_end)))
</span><span class="boring">                    } else {
</span><span class="boring">                        // Empty line.
</span><span class="boring">                        Some(Some((0, 0)))
</span><span class="boring">                    }
</span><span class="boring">                }
</span>            })
            .flatten()
            .map(move |(start, end)| &amp;line[start..end])
    })
<span class="boring">}
</span></code></pre></pre>
<p>And that's it!
If you run this code, you'll see the original input wrapped into lines no longer than 15 characters each.
Note that lines with non-ASCII multi-byte characters still count characters correctly, and hyphenated words are split across lines.</p>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>Using Rust's iterator API to perform word wrapping has a couple of advantages over something like hand-rolled loops.
As part of the standard library, I have strong confidence that these iterator adaptor functions are always correct.
Writing lots of nested loops by hand means extra code and lots of extra small book-keeping variables, each of which is a chance for bugs to slip in and cause headaches.
Using iterators also encapsulates all of these tracking variables into a single bundle inside the iterator: calling the <code>ruggrogue::word_wrap</code> function returns an iterator <em>immediately</em> so a <code>for</code> loop can process it all at its own pace.</p>
<p>However, I still don't feel like this iterator approach is the easiest code to read.
But in order to write a simpler version, stable Rust would need a language feature known as <em>generators</em>; look them up if you're curious.
Still, this word wrapping code manages to perform its work on demand, avoid memory allocations and is fast enough to run every frame, so all-in-all it worked out pretty well for the game.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="options.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="entity-component-system.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="options.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="entity-component-system.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
